/*******************************************************************************
 * Copyright (c) 2013 Eric Dill -- eddill@ncsu.edu. North Carolina State University. All rights reserved.
 * This program and the accompanying materials
 * are made available under the terms of the GNU Public License v3.0
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/gpl.html
 * 
 * Contributors:
 *     Eric Dill -- eddill@ncsu.edu - initial API and implementation
 * 	James D. Martin -- jdmartin@ncsu.edu - Principal Investigator
 ******************************************************************************/
package analysis;
import geometry.JVector;

import java.io.Serializable;
import java.util.Vector;

import Lists.Pair;
import calculate.Calibration;


/**
 * This class represents the idea of a "spot." A spot is a collection of pixels that correspond to the same
 * diffraction element.  A spot can calculate its total intensity and its weighted average x- and y- positions.
 * @author Eric Dill
 * 			eddill@ncsu.edu
 * @version 1.0
 */
public class Spot implements Serializable {

	/** autogenerated serialVersionUID */
	private static final long serialVersionUID = 9065082723438819365L;

	/** Array containing the pixels that comprise this spot */
	private Vector<Pixel> spot;

	/** Instance variable to hold the intensity-weighted average x-coordinate */
	private double x;
	/** Instance variable to hold the intensity-weighted average y-coordinate */
	private double y;
	/** Instance variable to hold the total intensity */
	private double I;
	
	private double q;
	private double phi;
	
	/** JVector: vector family, Double: confidence */
	private Vector<Pair<JVector, Double>> assignedFamily;
	
	private JVector assignedReflection;
	
	private String frameName;
	private int relativeFrameNumber;
	private int spotNumber;
	/**
	 * Constructor to initialize the array of pixels and set the pixel array pointer to zero
	 * @param numberOfPixels The number of pixels that the array needs to contain.
	 */
	public Spot(String frameName, int relativeFrameNumber)
	{
		/** the frame that this spot came from */
		this.frameName = frameName;
		
		/** create an empty linked list */
		spot = new Vector<Pixel>();
		
		this.relativeFrameNumber = relativeFrameNumber;
	}
	
	public Spot(double x, double y, double I) {
		this.x = x;
		this.y = y;
		this.I = I;
	}
	public Spot(Pixel[] pix) {
		spot = new Vector<Pixel>();
		for(Pixel p : pix)
			spot.add(p);
	}
	/**
	 * Add a pixel to the spot.  Increase the array size 50% if the pointer is at the end of the array
	 * @param toAdd The pixel to add to the spot.
	 */
	public void add(Pixel toAdd) { 
		spot.add(toAdd); 
	}
	
	/** 
	 * Method to determine the total intensity of the spot and calculate the intensity-weighted average 
	 * x- and y-coordinates.
	 */
	public void calculateSpotProperties(Calibration calib) {
		double curI;
		Pixel curPix;
		x = y = I = 0;
		double[] qPhi;
		for(int i = 0; i < spot.size(); i++) {
			 curPix = spot.elementAt(i);
			 if(calib == null)
				 qPhi = new double[] {0, 0};
			 else
				 qPhi = calib.coordsToQAndPhi(curPix.getX(), curPix.getY());
			 curPix.setDist(qPhi[0]);
			 curPix.setPhi(qPhi[1]);
			 curI = curPix.getIntensity();
			 I += curI;
			 x += curPix.getY() * curI;
			 y += curPix.getX() * curI;
			 phi += curPix.getPhi() * curI;
			 q += curPix.getDist() * curI;
		}
		x /= I;
		y /= I;
		phi /= I;
		q /= I;
	}
	
	/** GETTER METHODS */
	
	/**
	 * Getter method for the intensity-weighted average x-coordinate
	 * @return A double holding the intensity-weighted average x-coordinate
	 */
	public double getX() {
		if(x == 0) { calculateSpotProperties(null); }
		return x; 
	}
	
	/**
	 * Getter method for the intensity-weighted average y-coordinate
	 * @return A double holding the intensity-weighted average y-coordinate
	 */
	public double getY() { 
		if(y == 0) { calculateSpotProperties(null); }
		return y; 
	}
	
	/**
	 * Getter method for the total intensity of the spot
	 * @return	A double containing the total intensity for the spot
	 */
	public double getI() { 
		if(I == 0) { calculateSpotProperties(null); }
		return I; 
	}
	
	public String getFrameName() { return frameName; }
	public int getRelativeFrameNumber() { return relativeFrameNumber; }
	/**
	 * Return a tab-delimited string containing the intensity-weighted average x- and y-coordinates and the
	 * total intensity
	 */
	@Override
	public String toString() {
		return x + "\t" + y + "\t" + I + "\t" + q + "\t" + phi;
	}
	public void setSpotNumber(int spotNumber) { this.spotNumber = spotNumber; }
	public int getSpotNumber() { return spotNumber; }
	public Pixel[] getPixels() { return spot.toArray(new Pixel[spot.size()]); }
	public int getNumPixels() { return spot.size(); }
	public double getQ() { return q; }
	public void setQ(double q) { this.q = q; }
	public double getPhi() { return phi; }
	public void setPhi(double phi) { this.phi = phi; }
	public Vector<Pair<JVector, Double>> getAssignedFamily() { return assignedFamily; }
	public void setAssignedFamily(Vector<Pair<JVector, Double>> assignedFamily) { this.assignedFamily = assignedFamily; }
	public void addAssignedFamily(JVector vec, Double confidence) {
		if(assignedFamily == null)
			assignedFamily = new Vector<Pair<JVector, Double>>();
		
		assignedFamily.add(new Pair<JVector, Double>(vec, confidence));
	}
	public JVector getAssignedReflection() { return assignedReflection; }
	public void setAssignedReflection(JVector assignedReflection) { this.assignedReflection = assignedReflection; }
}
